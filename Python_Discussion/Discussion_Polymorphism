class Animal:
    def speak(self):
        print("The animal is making noise")
       
class Dog(Animal):
    def speak(self):
        print("The dog is making noise")
       
class Cat(Animal):
    def speak(self):
        print("The cat is making noise")
       
def mak_animal_speak(animal):
    animal.speak()
   
animals = [Dog(), Cat(), Animal()]
for a in animals:
    mak_animal_speak(a)
 
# static poly:
 
class Calculator:
    def add(self,a=None,b=None,c=None):
        if a is not None and b is not None and c is not None:
            return a+ b + c
        elif a is not None and b is not None:
            return a + b
        elif a is not None:
            return a
        else:
            return 0
       
calc = Calculator()
print(calc.add(10))
print(calc.add(10,2))
print(calc.add(10,2,3))
 
 
 
# duck  typeing:
 
class Bird:
    def fly(self):
        print("Bird can fly ")
       
class Airplane:
    def fly(self):
        print("Airplanr can fly ")
       
class Fish:
    def swim(self):
        print("fish can swim  ")
       
def let_it_fly(flyer):
    flyer.fly()
 
let_it_fly(Bird())
let_it_fly(Airplane())
let_it_fly(Fish())       # attributeError
   
 
class Product:
    def get_details(self):
        print("This is a generic product")
       
class Electronics(Product):
    def get_details(self):
        print("Electronics is a 1 year guanttee product")
       
class Clothing(Product):
    def get_details(self):
        print("Clothing is avaulable of all brands")
       
products = [Electronics(), Clothing()]
 
for item in products:
    item.get_details()
 
# operator overloading
 
class Book:
    def __init__(self,pages):
        self.pages = pages
       
    def __add__(self,other):
        return self.pages + other.pages
   
book1 = Book(100)
book2 = Book(200)
print(book1 + book2)
 
class Person:
    def __init__(self,name,age):
        self.name = name
        self.age = age
       
    def __repr__(self):
        return f"Person('{self.name}',{self.age})"
   
p = Person("Viren", 34)
print(repr(p))    # syntax
print(p)
 
# ---- __str__
 
class Person:
    def __init__(self,name,age):
        self.name = name
        self.age = age
       
    def __str__(self):
        return f"{self.name}', age is {self.age}"
   
p = Person("Viren", 34)
print(str(p))    # syntax
print(p)
 
p1 = Person('Ravi', 45)
print(p1)
 
# Static Polymorphism – Flight Search System
 
# Problem Statement:

# Implement static polymorphism using default arguments or variable-length arguments in a method called search_flights().
 
# Requirements:
 
# Create a class FlightSearch
 
# Implement search_flights() using:
 
# Default arguments
 
# Variable-length arguments (*args)
 
# Search by:
 
# Only airline
 
# Airline + destination
 
# Airline + destination + date
 
# Hint: Python doesn’t support true method overloading, so simulate it via default/optional/*args.
 
class FlightSearch:

    def search_flights(self, airline=None, destination=None, date=None):

        if airline and destination and date:

            print(f"Searching flights by {airline}, to {destination} on {date}")

        elif airline and destination:

            print(f"Searching flights by {airline}, to {destination}")

        elif airline:

            print(f"Searching flights by {airline}")

        else:

            print("Showing all available flights")
 
# Q7. Dynamic Polymorphism – Check-in System
 
# Problem Statement:

# Model a check-in system where each passenger type (e.g., Economy, Business) has a different check-in process.
 
# Requirements:
 
# Create a base class CheckIn
 
# Override the check_in_process() method in subclasses EconomyPassenger and BusinessPassenger
 
class CheckIn:

    def check_in_process(self):

        print("General check-in procedure")
 
class EconomyPassenger(CheckIn):

    def check_in_process(self):

        print("Economy check-in: Self-service kiosk")
 
class BusinessPassenger(CheckIn):

    def check_in_process(self):

        print("Business check-in: Priority desk")
 
# Q8. Dynamic Polymorphism – Notification System
 
# Problem Statement:

# Model a notification system that behaves differently based on communication type (Email, SMS, App Notification).
 
# Requirements:
 
# Base class: Notification
 
# Subclasses: EmailNotification, SMSNotification, AppNotification
 
# Override send() method in each subclass
 
# Q9. Static Polymorphism – Cargo Calculation System
 
# Problem Statement:

# Create a method to calculate total cargo weight using static polymorphism.
 
# Requirements:
 
# Use method with variable-length arguments (*args)
 
# Sum total cargo weight for a given list of items
 
class Cargo:

    def calculate_weight(self, *weights):

        total = sum(weights)

        print(f"Total cargo weight: {total} kg")
 
# Q10. Dynamic Polymorphism – Aircraft Maintenance Logs
 
# Problem Statement:

# Maintain aircraft logs with different levels of detail. Use dynamic polymorphism to customize log formats.
 
# Requirements:
 
# Base class: MaintenanceLog
 
# Subclasses: BasicLog, DetailedLog
 
# Override method display_log() in each subclass
 

 